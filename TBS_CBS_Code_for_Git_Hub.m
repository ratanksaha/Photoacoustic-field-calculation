clear all;
tic

% % % % This is a Matlab program that calculates the Photoacoustic field at various 
% % % % frequencies generated by a source using the Born-series methods (known as the 
% % % % Traditional Born Series and Convergent Born Series) in two dimensions. The 
% % % % source is assumed to be a circular disc. The program needs the following inputs to run.


% % % % Inputs- These parameters have to be given to the program to execute
% % Size of the computational domain, Nx=Ny=?
% % Grid size, dx=dy=?
% % Center of the computational domain, typically, Nmid=0.5*Nx+1
% % Width of the PML in terms of grid points, PML=?
% % Position of the detector in terms of grid points, Ndetect=?
% % Number of frequency points at which amplitudes of the PA field will be calculated, NFFT=?
% % Error tolerance, derror=?
% % Speed of sound in the ambient medium, vf=?
% % Speed of sound in the source region, vs=?
% % Radius of the source, a=? (assuming it is a circular disc)
% % Maximum number of iterations, MaxIT=?
% % 
% % % % Output 
% % Shirfn

vs=1500;

Ny=2048;
Nx=2048;
Nmid=1025;
dx=100e-9;  %in m
epsconst=0.8;
PML=100;
Ndetect=1852;
NFFT=274;
derror=1e-4;
MaxIT=2000;

a=50*dx;
Nbox=100;

vf=1500;

mu=1.0;
beta=1.0;
I0=1.0;
Cp=1.0;

kkxy=2*pi*(1:Nmid-1)/(Nx*dx);
f=kkxy*vf/(2*pi);   % in Hz

f11=f/1000000;

V=zeros(Ny, Nx);
S=zeros(Ny, Nx);
Shimask=zeros(Ny, Nx);
pmod2=zeros(Ny, Nx);


for j22=1:Nx
    kx=2*pi*(j22-Nmid)/(Nx*dx);
    for i22=1:Ny
        ky=2*pi*(i22-Nmid)/(Nx*dx);
        pmod2(i22, j22)=kx*kx+ky*ky;
    end
end

tic
for i1=1:NFFT   %546
    tic;
    omega=2*pi*f(i1);
    ks=omega/vs;
    k=omega/vf;
    epsilon=epsconst*k*k;
    epsilon11=sqrt(epsilon);
    
    V=-i*epsilon*ones(Ny, Nx);
    S=zeros(Ny, Nx);
    
    for j22=Nmid-Nbox:Nmid+Nbox
        xg=(j22-Nmid)*dx;
        for i22=Nmid-Nbox:Nmid+Nbox
            yg=(i22-Nmid)*dx;
            rg=sqrt(xg*xg+yg*yg);
            if(rg<=a)
                V(i22, j22)=ks*ks-k*k-i*epsilon;
                S(i22, j22)=-i*omega*mu*beta*I0/Cp;
            end
        end
    end
    
    Shimask=ones(Ny, Nx);
    
    for j33=1:Nx
        xg=(j33-Nmid)*dx;
        for i33=1:PML
            yg=(i33-Nmid)*dx;
            rg=sqrt(xg*xg+yg*yg);
            Shimask(i33, j33)=exp(-epsilon11*rg);
        end
    end
    
    for j33=1:Nx
        xg=(j33-Nmid)*dx;
        for i33=Ny-PML+1:Ny
            yg=(i33-Nmid)*dx;
            rg=sqrt(xg*xg+yg*yg);
            Shimask(i33, j33)=exp(-epsilon11*rg);
        end
    end
    
    for j33=1:PML
        xg=(j33-Nmid)*dx;
        for i33=PML+1:Ny-PML
            yg=(i33-Nmid)*dx;
            rg=sqrt(xg*xg+yg*yg);
            Shimask(i33, j33)=exp(-epsilon11*rg);
        end
    end
    
    for j33=Nx-PML+1:Nx
        xg=(j33-Nmid)*dx;
        for i33=PML+1:Ny-PML
            yg=(i33-Nmid)*dx;
            rg=sqrt(xg*xg+yg*yg);
            Shimask(i33, j33)=exp(-epsilon11*rg);
        end
    end
   
    
    temp11=pmod2-k*k-i*epsilon;
    G=1./temp11;
    G=fftshift(G);
    
    gamma=i*V/epsilon;
    
    Shirin=ifft2(G.*fft2(S));   % for TBS
% %     Shirin=gamma.*(ifft2(G.*fft2(S))); % for CBS
    
    Shirfn=zeros(Ny, Nx);
        
    for i77=1:MaxIT
        Shirfn=ifft2(G.*fft2(V.*Shirin+S));  % for TBS
% %         Shirfn=Shirin-(i/epsilon)*V.*(Shirin-ifft2(G.*fft2(V.*Shirin+S)));  % for CBS
        
        error_fn_in = norm(Shirfn(Nmid,:) - Shirin(Nmid,:))/norm(Shirin(Nmid,:));
               
        if(error_fn_in<derror)
            saturationCBS = i77;
            break
        else
            Shirin = Shirfn;
            Shirfn=Shirfn.*Shimask;
        end
    end
        
    toc
end


toc